# Java

## 继承

* 父类的构造方法无论如何都无法继承，若无构造函数，会默认创建空参构造。
* 父类的成员变量无论如何都可以继承，但只有`public`和`protect`修饰的才可以直接调用，`private`修饰的需要通过`get/set`方法才能获取和修改
* 父类的成员方法：JVM会将非`private`、非`static`和非`final`的方法添加到虚方法表中，并将虚方法表递交给子类，子类会在父类虚方法表的基础上添加自身的虚方法。如果调用时在虚方法表中没有找到对应的方法，程序会一层一层向上层寻找该方法。（即只有父类中的虚方法才能被继承）
* 子类构造函数会优先访问父类的空参构造
### 构造方法的访问特点

* 子类不能继承父类的构造方法，但是可以通过`super`调用
* 子类构造方法的第一行，有一个默认的`super()`
* 默认先访问父类中无参的构造方法，再执行自身的构造函数
* 如果想要调用有参构造，需要手动书写

### 成员变量访问特点

​	就近原则

### `this`和`super`使用总结

​	`this`：相当于一个变量，表示当前方法调用者的地址值

```java
public class Student {
    String name;
    int age;

    public void show(Student this) {
        System.out.println(name + "，" + age);
    }
}
```


```java
public class Test {
    public static void main(String[] args) {
        Student s = new Student();
        s.name = "张三";
        s.age = 22;
        s.show();
    }
}
```

​	`super`：父类的存储空间

## 多态

​	同类型的对象，表现出不同的形态

### 多态的前提

* 有继承或实现关系

* 有父类引用指向子类对象`Fu fu = new Zi();`

* 有方法重写

### 多态的好处

​	使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性和便利

### 多态调用成员的特点

* 变量调用：编译看左边，运行看左边

* 方法调用：编译看左边，运行看右边

```java
public class AnimalTest {
    public static void main(String[] args) {
        // 左边动物类，右边狗类
        Animal a = new Dog();
        // name 是成员变量，编译看左边，运行时看左边，左边是动物类
        // 若左部没有当前成员变量，编译失败
        System.out.println(a.name);
        // show 是成员方法，编译看左边，运行时看右边，右边是狗类
        // 若左部没有当前成员方法，编译失败
        a.show();
    }
}

class Animal {
    String name = "动物";

    public void show() {
        System.out.println(name);
    }
}

class Dog extends Animal {
    String name = "狗";

    @Override
    public void show() {
        System.out.println(name);
    }
}

class Cat extends Animal {
    String name = "猫";

    @Override
    public void show() {
        System.out.println(name);
    }
}

```

​	运行结果

```
动物
狗
```

### 多态的优缺点

* 优点：

  1. 在多态形式下，右边对象可以实现解耦合，便于扩展和维护

     ```
     Person p = new Student();
     p.work();//业务逻辑发生改变时，后续代码无需修改
     ```

  2. 定义方法时，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利

* 缺点：
  1. 不能调用子类的特有方法（解决方法：强制类型转换）
  2. 

### `instanceof`关键字

​	使用方法：a表示变量名，b表示类型名，用于判断a是否是b类型，返回`boolean`值

```java
a instanceof b
```

​	Java14新特性：

```java
// 先判断a是否为Dog类型，是则强转，并赋值给新变量d
if (a instanceof Dog d) {

} else if (a instanceof Cat c) {
            
}
```

## 包

​	包就是文件夹，用来管理各种不同功能的Java类，方便后期代码维护

### 包名的规则

​	公司域名反写+包的作用，需要全部英文小写，见名知意

### 使用其他类的规则

* 使用同一个包中的类时，不需要导包
* 使用`java.lang`包中的类时，不需要导包
* 其他情况都需要导包
* 如果同时存在两个包中的同类名，需要使用全类名

## `final`关键字

​	`final`关键字可以用修饰方法、类和变量

* `final`修饰方法，表明该方法是最终方法，不能被重写
* `final`修饰类，表明该类是最终类，不能被继承
* `final`修饰变量，表明该变量是常量，只能被赋值一次

### 常量

​	实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性

#### 命名规范

* 单个单词：全部大写
* 多个单词：全部大写，单词间用下划线隔开

#### 细节

* `final`修饰的变量是基本类型：那么变量存储的数据值不能发生改变
* `final`修饰的变量是应用类型：那么变量存储的地址值不能发生改变，对象内部可以改变

## 权限修饰符

* 权限修饰符：用来控制一个成员能够被访问的范围
* 可以修饰成员变量，方法，构造方法，内部类

```java
public class Student {
	private String name;
    private int age;
}
```

### 权限修饰符的分类

​	`private`<缺省<`protect`<`public`

## 代码块

* 局部代码块

  写在方法中，提前结束代码块生命周期（已淘汰）

* 构造代码块

  写在成员位置的代码块，可以把多个构造方法中重复的代码抽取出来，优先于构造方法执行

* 静态代码块

  - 格式：`static {}`
  - 特点：需要通过`static`关键字修饰，随着类的加载而加载，自动触发且只执行一次

## 抽象类

​	`abstract`

### 抽象方法

​	将共性的行为（方法）抽取到父类后，由于每个子类执行的内容不一样，所以在父类中不能确定具体的方法体，该方法就可以使用抽象方法

```java
// 抽象方法不含方法体
public abstract 返回值类型 方法名(参数列表);
```

### 抽象类

​	如果一个类中存在抽象方法，那么该类就必须声明为抽象类

```java
public abstract class 类名 {}
```

### 注意事项

* 抽象类不能实例化（创建对象）
* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
* 抽象类可以有构造方法（创建子类对象时赋值）
* 抽象类的子类：
  - 要么重写抽象类中的所有抽象方法
  - 要么是抽象类

## 接口

​	接口是一种规则，是对行为的抽象，想要一个类拥有某个行为，只需要实现对应的接口即可。当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态

### 定义和使用

* 接口使用关键字`interface`来定义

  ```java
  public interface 接口名 {}
  ```

* 接口不能实例化

* 接口和类之间是实现关系，通过`implement`关键字表示

  ```java
  public class 类名 implements 接口名 {}
  ```

* 接口的子类（实现类）：
  - 要么重写接口中的所有抽象方法
  - 要么是抽象类

### 注意事项

* 接口和类的实现关系，可以单实现，也可以多实现

  ```java
  public class 类名 implements 接口1, 接口2 {}
  ```

* 实现类还可以在继承一个类的同时实现多个接口

  ```java
  public class 类名 extends 父类 implements 接口1, 接口2 {}
  ```

* 接口中的方法可以不加`public`和`abstract`，因为接口都是需要实现的，默认包含这两个修饰

### 接口中成员的特点

* 成员变量：
  - 只能是常量
  - 默认修饰符：`public static final`

* 构造方法：

  接口没有构造方法

* 成员方法：
  - 只能是抽象方法（JDK7之前）
  - 默认修饰符：`public abstract`
  - JDK8：接口中可以定义有方法体的方法
  - JDK9：接口中可以定义私有方法

### 接口以及类之间的关系

* 类和类的关系：

  继承关系，只能单继承，不能多继承，但是可以多层继承

* 类和接口的关系：

  实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

  对于多个接口中的重名方法，只需要重写一次

* 接口和接口的关系：

  继承关系，可以单继承，也可以多继承

### JDK8新增方法

​	接口中可以定义有方法体的方法（默认方法和静态方法）

默认方法：

- 允许在接口中定义默认方法，需要使用关键字`default`修饰

- 作用：解决接口升级的问题

- 格式：`public default 返回值类型 方法名(参数列表) {}`

- 范例：

  ```java
  public default void show() {}
  ```
  
- 注意事项：

  * 默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候需要去掉`default`关键字
  * `public`可以省略，`default`不可省略
  * 如果实现了多个接口，多个接口存在重名的默认方法，子类就必须对该方法进行重写

静态方法：

* 允许在接口中定义静态方法，需要使用关键字`static`修饰

* 格式：`public static 返回值类型 方法名(参数列表) {}`

* 范例：

  ```java
  public static void show() {}
  ```

* 注意事项：

  * 静态方法只能通过接口名调用，不能通过实现类名或对象名通用
  * `public`可以省略，`static`不可省略

### JDK9新增的方法

​	接口中可以定义（带静态的）私有方法

私有方法：

* 格式：`private 返回值类型 方法名(参数列表) {}`

* 范例：

  ```java
  private void show() {}
  ```

带静态的私有方法：

* 格式：`private static 返回值类型 方法名(参数列表) {}`

* 范例：

  ```java
  private static void show() {}
  ```

### 适配器设计模式

​	设计模式（Design pattern）是一套被反复使用、多数人知晓、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码的可靠性、程序的重用性。

​	适配器设计模式：解决接口与接口实现类之间的矛盾问题，当一个接口中的抽象方法过多，但只需要使用其中一部分方法的时候，可以使用适配器设计模式。

​	适配器设计模式步骤：

* 编写中间类XXXXAdapter，实现对应的接口，对接口中的抽象方法进行空实现
* 让真正的实现类去继承中间类，并重写需要的方法
* 为了避免其他类创建适配器对象，适配器类使用`abstract`进行修饰

## 内部类

* 类的五大成员：属性、方法、构造方法、代码块、内部类
* 什么是内部类：在类的内部在定义一个类

 * 内部类访问特点：
   1. 内部类可以直接访问外部类的成员，包括私有
   2. 外部类要访问内部类成员，必须创建对象

```java
public class A { // 外部类
    String v1;
    int v2;
    
    class B {  // 内部类
    	int v3;    
    }
}
```
### 成员内部类

写在成员位置，属于外部类的成员，以上代码的 `class B`就是成员内部类

* 成员内部类：

  * 成员内部类可以被一些修饰符修饰，比如`private 默认 protected public static`等
  * 使用`static`修饰的，是静态内部类
  * 在成员内部类里面，JDK16之前不允许定义静态变量，JDK16开始可以定义静态变量

* 获取成员内部类对象：

  * 方式一：在外部类中编写方法，对外提供内部类的对象

  * 方式二：直接创建：`外部类名.内部类名 对象名 = 外部类对象.内部类对象`

    范例：

    ```java
    Outer.Inner oi = new Outer().new Inner();
    ```
  
* 成员内部类访问外部类变量：

  `Outer.this.v`
### 静态内部类

​	静态内部类是一种特殊的成员内部类，当成员内部类使用`static`修饰时称为静态内部类

​	静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态需要创建对象

```
public class Outer {
    static class Inner {  // 静态内部类
		
    }
}
```



 * 创建静态内部类：`外部类名.内部类名 对象名 = new 外部类名.内部类名();`

   范例：

   ```java
   Outer.Inner oi = new Outer.Inner();
   ```

 * 调用非静态：先创建对象，通过对象调用

	* 调用静态：`外部类名.内部类名.方法名();`

### 局部内部类

​	将内部类定义在方法里，就叫做局部内部类

​	外界无法直接使用，需要在方法内部创建对象并使用

​	该类可以直接访问外部类的成员，也可以访问方法内的局部变量

```java
public class Outer {
	public void method() {
		class Inner {  // 局部内部类
		
		}
	}
}
```

### 匿名内部类

​	在创建对象时才会编写类体，是一种隐藏了名字的内部类

​	包含了继承或实现，方法重写，创建对象，整体就是一个类的子类对象或者接口的实现类对象

* 格式：

  ```java
  new 父类名或父接口名() {
  	子类重写方法
  }; // 注意有;
  ```

* 范例：

  ```java
  new Inner() {
      public void show() {
          
      }
  };
  ```
  
* 创建对象

  ```java
  Inner i = new Inner() {
      public void show() {
          
      }
  };
  ```

* 实际演示：

  ```java
  // Swim.java
  public interface Swim {
      void swim();
  }
  ```

  ```java
  // Test.java
  public class Test {
      public static void main() {
          // 内部类
          new Swim() {
              @Override
              public void swim() {
                  
              }
          };
      }
  }
  ```

